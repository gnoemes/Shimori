import com.gnoemes.shimori.data.core.entities.common.AgeRating;
import com.gnoemes.shimori.data.core.entities.common.Genre;
import com.gnoemes.shimori.data.core.entities.common.TitleStatus;
import kotlin.collections.List;
import kotlinx.datetime.Instant;
import kotlinx.datetime.LocalDate;

CREATE TABLE anime (
    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    shikimori_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    name_ru TEXT,
    name_eng TEXT,
    image_original TEXT,
    image_preview TEXT,
    image_x96 TEXT,
    image_x48 TEXT,
    url TEXT,
    anime_type TEXT,
    rating REAL AS Double,
    status TEXT AS TitleStatus,
    episodes INTEGER AS Int NOT NULL,
    episodes_aired INTEGER AS Int NOT NULL,
    date_aired TEXT AS LocalDate,
    date_released TEXT AS LocalDate,
    age_rating TEXT AS AgeRating NOT NULL,
    description TEXT,
    description_html TEXT,
    franchise TEXT,
    favorite INTEGER AS Boolean NOT NULL,
    topic_id INTEGER,
    genres TEXT AS List<Genre>,
    duration INTEGER AS Int,
    next_episode INTEGER AS Int,
    next_episode_date INTEGER AS Instant,
    next_episode_end_date INTEGER AS Instant
);

CREATE UNIQUE INDEX anime_shikimori_id ON anime(shikimori_id);
CREATE INDEX anime_next_episode_date ON anime(next_episode_date);

insert:
INSERT OR REPLACE INTO anime(shikimori_id, name, name_ru, name_eng, image_original, image_preview,
image_x96, image_x48, url, anime_type, rating, status, episodes, episodes_aired,
date_aired, date_released, age_rating,  description, description_html, franchise, favorite,
topic_id, genres, duration, next_episode, next_episode_date, next_episode_end_date)
VALUES (?,?,?,?,?,?,?,?,?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

update:
INSERT OR REPLACE INTO anime(id, shikimori_id, name, name_ru, name_eng, image_original, image_preview,
image_x96, image_x48, url, anime_type, rating, status, episodes, episodes_aired,
date_aired, date_released, age_rating, description, description_html, franchise, favorite,
topic_id, genres, duration, next_episode, next_episode_date, next_episode_end_date)
VALUES ?;


deleteAll:
DELETE FROM anime;

deleteById:
DELETE FROM anime WHERE id = :id;

countWithStatus:
SELECT COUNT(*) FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
WHERE r.status = :status;

queryAll:
SELECT * FROM anime;

queryById:
SELECT * FROM anime WHERE id = :id;

queryByIdWithRate:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE title.id = :id;

queryIdByShikimoriId:
SELECT id FROM anime WHERE shikimori_id = :shikimoriId;

queryByStatus:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status;

queryByStatusSortName:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN name END) DESC,
(CASE :descending WHEN 0 THEN name END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortNameRu:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN name_ru END) DESC,
(CASE :descending WHEN 0 THEN name_ru END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortProgress:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN progress END) DESC,
(CASE :descending WHEN 0 THEN progress END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortDateCreated:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN date_created END) DESC,
(CASE :descending WHEN 0 THEN date_created END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortDateUpdated:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN date_updated END) DESC,
(CASE :descending WHEN 0 THEN date_updated END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortDateAired:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN datetime(date_aired) END) DESC,
(CASE :descending WHEN 0 THEN datetime(IFNULL(date_aired, '9999-12-31')) END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortScore:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN score END) DESC,
(CASE :descending WHEN 0 THEN score END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortSize:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN episodes END) DESC,
(CASE :descending WHEN 0 THEN episodes END) ASC
LIMIT :limit OFFSET :offset;

queryByStatusSortRating:
SELECT * FROM anime AS title
INNER JOIN rate AS r ON r.target_id = title.id AND r.target_type = "ANIME"
LEFT OUTER JOIN pinned AS p ON p.target_id = title.id AND p.target_type = r.target_type
WHERE r.status = :status
ORDER BY
(CASE :descending WHEN 1 THEN rating END) DESC,
(CASE :descending WHEN 0 THEN rating END) ASC
LIMIT :limit OFFSET :offset;
